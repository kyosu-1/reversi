# Reversi WebSocket Server

このプロジェクトは、リバーシゲームのWebSocketサーバーです。ゲームの状態を管理し、クライアントとリアルタイムに通信します。

## Architecture

本プロジェクトは以下の3つの主要なパーツで構成されています。

1. `game`: リバーシゲームのルールとロジックを実装します。
2. `server`: WebSocketサーバーの機能を提供します。新しいクライアント接続の処理、各クライアントからのメッセージの処理、クライアントとゲームボードの状態の同期などを行います。
3. `strategy`: コンピュータプレイヤーの戦略を定義します。

## Game

`game`パッケージでは、リバーシのゲームロジックが実装されています。具体的には、ボードの状態を表現する`Board`型と、それを操作するための一連のメソッドが提供されています。

## Server

`server`パッケージでは、WebSocketサーバーのロジックが実装されています。新しいクライアント接続を受け入れ、ゲーム状態をクライアントと同期し、クライアントからのメッセージを処理します。サーバーは主に`Server`型とそのメソッドで構成されており、`Message`型はサーバーとクライアント間でやり取りするメッセージの形式を定義します。

## Strategy

`strategy`パッケージでは、コンピュータプレイヤーの戦略が実装されています。`Strategy`インターフェースは全ての戦略が実装すべきメソッドを定義し、`RandomStrategy`型はその一例としてランダムな手を選ぶ戦略を実装しています。

新しい戦略を追加するには、新たな型を定義し、その型に対して`Strategy`インターフェースの`BestMove`メソッドを実装します。それを`Server`のインスタンスを作成する際の引数として渡すことで、その戦略を利用するようにできます。

## WebSocket Messages

WebSocketメッセージはJSON形式で送受信されます。メッセージは大きく2種類あります。

1. `move`: クライアントからサーバーへ送られます。プレイヤーが石を置く位置を指定します。データフィールドは`{"x": <int>, "y": <int>}`形式です。
2. `update`: サーバーからクライアントへ送られます。ゲームの最新の状態を表します。データフィールドは現在の`Board`の状態です。

## Building and Running

Goがインストールされている環境で以下のコマンドを実行してください。

```bash
# プロジェクトのビルド
go build

# サーバーの起動 (デフォルトポートは8080)
go run cmd/server/main.go
```

## Usage

サーバーが起動したら、クライアントはWebSocketでサーバーに接続します。デフォルトでは`ws://localhost:8080/ws`でサーバーは待ち受けています。

接続が確立すると、サーバーは初期ゲーム状態を表す`update`メッセージを送信します。クライアントは`move`メッセージを送信してゲームを進行させ、サーバーからの`update`メッセージを受信してゲームの状態を更新します。

コンピュータプレイヤーのターンでは、サーバーが自動的に次の手を選択し、その結果を`update`メッセージとして送信します。

## Message

WebSocketメッセージは、JSON形式でデータをやり取りします。各メッセージは特定のタイプを持ち、そのタイプによってメッセージの内容と目的が決まります。

以下に、APIサーバーで想定されるWebSocketメッセージの形式とその役割を記述します。

1. **Initメッセージ（クライアントからサーバー）**
   
   プライヤーがwsとの接続を開始する際に送信されます。このメッセージはゲームの初期状態を含みます。

   ```json
   {
        "type": "init",
        "data": {
            "board": [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 2, 0, 0, 0],
            [0, 0, 0, 2, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]
            ],
        "next": 1
      }
   }
   ```

2. **Moveメッセージ（クライアントからサーバーへ）**

    プレイヤーがゲームの一手を行うために使用します。このメッセージは、プレイヤーが手を打つ座標（XとY）を含みます。

    ```json
    {
        "type": "move",
        "data": {
        "x": 3,
        "y": 4
        }
    }
    ```

3. **Stateメッセージ（サーバーからクライアントへ）**

    サーバーが現在のゲームの状態をクライアントに伝えるために使用します。このメッセージは、ゲームボードの状態と次に手番が来るプレイヤーの色を含みます。

    ```json
    {
      "type": "state",
      "data": {
        "board": [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 2, 0, 0, 0],
          [0, 0, 0, 2, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
        ],
        "next": 1
      }
    }
    ```

    上記のゲームボードは8x8の2D配列で、0は空きマス、1は黒の石、2は白の石を表します。"next"は次に手番が来るプレイヤーの色を示します（1: 黒、2: 白）。

4. **Errorメッセージ（サーバーからクライアントへ）**

    サーバーがクライアントにエラーメッセージを送るために使用します。このメッセージは、エラーメッセージの内容を含みます。

    ```json
    {
      "type": "error",
      "data": {
        "message": "Invalid move."
      }
    }
    ```
